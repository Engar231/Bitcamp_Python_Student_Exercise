ğŸ“ Progetto di Riepilogo â€“ Python & Intelligenza Artificiale
ğŸ§­ Scenario e obiettivo generale
Lâ€™obiettivo Ã¨ sviluppare unâ€™applicazione completa per la gestione dei dati scolastici degli studenti e la predizione del loro esito finale (Promosso/Bocciato) attraverso modelli di Machine Learning. Lâ€™app dovrÃ  gestire i dati in locale, fornire una GUI intuitiva, generare un report completo e poter essere installata su qualsiasi PC Windows.

ğŸ”¨ Fase 1: Raccolta e gestione procedurale dei dati
ğŸ“‹ Obiettivo
Creare uno script procedurale che consenta:
- lâ€™inserimento manuale di studenti;
- il salvataggio in file CSV;
- la lettura e modifica dei dati salvati.

ğŸ§© Campi richiesti
Ogni studente dovrÃ  avere i seguenti dati:

Campo		Tipo	Obbligatorio	Note
id		int		âœ…	univoco
nome		string		âœ…	lista nomi maschili
cognome		string		âœ…	lista nomi femminili
etÃ 		int		âœ…	14-20
genere		string		âœ…	M/F
ore_studio	float		âœ…	settimanali
assenze		int		âœ…	numero
media_voti	float		âœ…	da 4 a 10
comportamento	string		âœ…	Ottimo, Buono, Sufficiente, Scarso
esito_finale	string		âœ…	Promosso, Bocciato

ğŸ§ª FunzionalitÃ  minime
Menu testuale (in console) per:
- aggiungere nuovo studente
- mostrare tutti gli studenti
- modificare uno studente esistente
- salvare in studenti.csv
- caricare da studenti.csv
- Controlli di input validi

Per riuscire a popolare il dataset con una certa coerenza, vorrei una funzione 
che simuli la generazione di un dataset di studenti con caratteristiche casuali, 
fino a raggiungere una certa condizione statistica, ovvero devi sviluppare 
un sistema che generi un insieme di dati (dataset) di studenti. 
Ogni studente Ã¨ descritto da vari attributi, come:

 -ID univoco
 -Nome (maschile o femminile)
 -Cognome
 -EtÃ  (da 14 a 20 anni)
 -Genere (M o F)
 -Ore di studio giornaliere (valore decimale realistico tra 0 e 8)
 -Numero di assenze (intero casuale)
 -Media voti (da 4 a 10, con un decimale)
 -Comportamento (tra: Ottimo, Buono, Sufficiente, Scarso)
 -Esito finale (Promosso o Bocciato), determinato da una logica specifica.

Generazione di studenti casuali:
-I nomi devono essere scelti casualmente da due liste separate (nomi maschili e femminili).
-I cognomi devono essere scelti casualmente da una lista predefinita.
-Lâ€™esito finale deve essere determinato secondo questa logica:
-Se il comportamento Ã¨ â€œScarsoâ€ â†’ Bocciato
-Se la media voti Ã¨ â‰¤ 5.3 â†’ Bocciato
-Se le assenze sono esattamente 220 â†’ Bocciato
-Altrimenti â†’ Promosso

Generazione iterativa del dataset:
-Generare studenti in â€œbatchâ€ di dimensione definita (ad esempio 200 studenti per batch).
-Continuare a generare batch e aggiungerli al dataset totale finchÃ© la percentuale di studenti promossi non supera il 60% sul totale degli studenti generati finora.
-Stampare a video come promemoria il numero totale di studenti, il numero di promossi e la percentuale di promossi dopo ogni batch generato.

Salvataggio del dataset:
-Quando la percentuale di promossi supera il 60%, terminare la generazione.
-Salvare il dataset finale in un file CSV chiamato studenti.csv.


ğŸ§­ Fase 2: Refactoring ad oggetti (OOP)
ğŸ“‹ Obiettivo
Convertire il codice in stile OOP con:
-classe Studente
-classe GestoreStudenti

ğŸ§± Struttura consigliata
class Studente:
    def __init__(self, id, nome, cognome, etÃ , genere, ore_studio, assenze, media_voti, comportamento, esito_finale):
        ...

class GestoreStudenti:
    def __init__(self):
        self.studenti = []

    def aggiungi_studente(self, studente):
        ...

    def salva_csv(self, nome_file):
        ...

    def carica_csv(self, nome_file):
        ...
â• Extra suggeriti
-metodo __str__() nella classe Studente
-menu testuale che richiama i metodi della classe GestoreStudenti


ğŸ§­ Fase 3: Database SQLite3
ğŸ“‹ Obiettivo
Trasferire la gestione dati da file CSV a database SQLite3.

ğŸ“‚ Database: studenti.db
Tabella: studenti
Campo		Tipo		Vincoli
id		INTEGER		PRIMARY KEY
nome		TEXT		NOT NULL
cognome		TEXT		NOT NULL
etÃ 		INTEGER		CHECK(14 â‰¤ etÃ  â‰¤ 20)
genere		TEXT		CHECK(genere IN ('M','F'))
ore_studio	REAL		â‰¥ 0
assenze		INTEGER		â‰¥ 0
media_voti	REAL		1-10
comportamento	TEXT		CHECK(valore valido)
esito_finale	TEXT		CHECK(valore valido)

ğŸ§ª FunzionalitÃ  minime
Creazione tabella se non esiste
-Inserimento nuovo studente
-Visualizzazione tabella
-Modifica e cancellazione record
-Esportazione completa in studenti.csv

â• Extra suggeriti
Popola con almeno 150 studenti (puoi realizzare una funzione che realizzi il popolamento)

ğŸ§­ Fase 4: Preprocessing e trasformazione in DataFrame
ğŸ“‹ Obiettivo
Convertire i dati da studenti.db o studenti.csv in un DataFrame per il ML.

ğŸ” Trasformazioni da applicare
-Codifica label (es. comportamento â†’ numeri)
-Normalizzazione delle variabili numeriche
-Split train/test (es. 80/20)
-Salvataggio dei DataFrame in file CSV per debug

ğŸ§­ Fase 5: Machine Learning supervisionato
ğŸ“‹ Obiettivo
Allenare piÃ¹ modelli di classificazione per prevedere esito_finale.

âœ… Modelli obbligatori
-DecisionTreeClassifier
-KNNeighborsClassifier
-GaussianNB
-SVM
-RandomForestClassifier

ğŸ“ˆ Metriche richieste
-Accuratezza
-Matrice di confusione
-Precision / Recall / F1

â• Extra suggeriti
-salvataggio del modello joblib
-confronto prestazioni dei modelli

ğŸ§­ Fase 6: Clustering non supervisionato (KMeans)
ğŸ“‹ Obiettivo
-Segmentare gli studenti in gruppi basati su performance/assenze/ore studio.
-Grafico a dispersione (Matplotlib)
-Esportazione cluster nel report

ğŸ§­ Fase 7: GUI con tkinter
ğŸ“‹ Obiettivo
Creare unâ€™interfaccia semplice con le seguenti funzioni:
-Inserimento dati nuovo studente
-Salvataggio dati nuovo studente su database
-Predizione del modello salvato per nuovo studente
-Visualizzazione statistiche
-Esportazione in PDF del report con grafici

ğŸ§­ Fase 8: Report PDF
ğŸ“‹ Contenuti
-Elenco studenti (nome + esito previsto)
-Grafici: Matrice di Confusione, KMeans, Voti/Assenze
-Sommario delle metriche
-Timestamp, autore, modello usato

ğŸ“¦ Librerie suggerite: reportlab o fpdf, + matplotlib

ğŸ§­ Fase 9: Compilazione in eseguibile + installer
-Realizza l'eseguibile per il programma di classificazione/predizione
-Realizza l'installer per il programma di classificazione/predizione